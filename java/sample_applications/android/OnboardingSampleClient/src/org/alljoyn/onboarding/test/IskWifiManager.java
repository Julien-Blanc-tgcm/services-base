/******************************************************************************
 * Copyright (c) 2013, AllSeen Alliance. All rights reserved.
 *
 *    Permission to use, copy, modify, and/or distribute this software for any
 *    purpose with or without fee is hereby granted, provided that the above
 *    copyright notice and this permission notice appear in all copies.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 ******************************************************************************/

package org.alljoyn.onboarding.test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

import org.alljoyn.onboarding.OnboardingService.AuthType;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.util.Log;

/**
 *  
 */
public class IskWifiManager 
{
	
	final String INT_ENTERPRISEFIELD_NAME ="android.net.wifi.WifiConfiguration$EnterpriseField";
	
	private static final String TAG = "IskWifiManager";
	private Context m_context;
	//  Android Wi-Fi manager
	private WifiManager m_wifi;
	// Listener for events generated by this class
	private WifiManagerListener m_listener;
	// Receiver for Wi-Fi intents
	private BroadcastReceiver m_scanner;
	

	//================================================================
	public IskWifiManager(Context c) {
		m_context = c;
		m_wifi = (WifiManager) m_context.getSystemService(Context.WIFI_SERVICE);		
	}
	//================================================================
	/**
	 * Kick off a Wi-Fi scan, after registering for Wi-Fi intents
	 * @param c context
	 * @param listener listener to events generated by this class
	 * @param AJlookupPrefix filter for discovered devices
	 */
	public void scanForWifi(Context c, WifiManagerListener listener, String AJlookupPrefix)
	{
		m_listener = listener;
		m_context = c;
		m_wifi = (WifiManager) m_context.getSystemService(Context.WIFI_SERVICE);

		// listen to Wi-Fi intents
		m_scanner = new BroadcastReceiver() {

			// will get here after scan
			@Override
			public void onReceive(Context context, Intent intent) 
			{
				// === Current scans ===
				List<ScanResult> scans = m_wifi.getScanResults();
				
				// remove duplicate SSID with different BSSID ,
				if (scans != null){
					
					// keep one item per SSID, the one with the strongest signal
					HashMap<String, ScanResult> alljoynSoftAPs = new HashMap<String, ScanResult>(); 
					for (ScanResult currentScan : scans){
						ScanResult l=alljoynSoftAPs.get(currentScan.SSID);
						if (l==null)
						{
							alljoynSoftAPs.put(currentScan.SSID, currentScan);
						}else{
							if (l.level<currentScan.level)
							{
								alljoynSoftAPs.put(currentScan.SSID, currentScan);
							}
						}

					}
					
					// sort list by level of Wi-Fi signal
					List <ScanResult> list=new ArrayList<ScanResult>(alljoynSoftAPs.values());
					Collections.sort(list, new Comparator<ScanResult>() {
						public int compare(ScanResult o1, ScanResult o2) {
							if ( o1.level>o2.level)
								return -1;
							else if ( o1.level<o2.level)
								return 1;
							else 
								return 0;
						}
					});
					// listener callback
					m_listener.OnScanResultComplete(list);

				}
			}
		};
		
		// register for Wi-Fi intents that will be generated by the scanning process
		IntentFilter filter = new IntentFilter();
		filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
		filter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
		filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
		filter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
		filter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
		filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
		filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
		m_context.registerReceiver(m_scanner, filter);
		
		// start a scan
		m_wifi.startScan();
		
	}
	
	//================================================================
	public void unregisterWifiManager(){
		if(m_scanner != null){
    		try{
    			if(m_context != null)
    				m_context.unregisterReceiver(m_scanner);
    		} catch (Exception e) {
			}
    	}
	}
	//================================================================
	
	/**
	 * Connect to a a Wi-Fi Access Point
	 * @param networkName SSID of the network
	 * @param passkey Wi-Fi password
	 * @param capabilities the Wi-Fi capabilities string: supported authentication
	 * @param isPasswordASCII indicates whether the password is in ASCII format or HEX.
	 * @return
	 */
	public boolean connectToAP(String networkName, String passkey, String capabilities, boolean isPasswordASCII) 
	{
	    Log.i(TAG, "* connectToAP with capabilities");
	    AuthType securityMode = getScanResultSecurity(capabilities);
	    return connectToAP(networkName,passkey,isPasswordASCII,securityMode.getTypeId());
	}
	//================================================================
	
	/**
	 * Map a capabilities string from Android's scan to AllJoyn Onboarding service AuthType enum
	 * @param capabilities the AP's capabilities screen. Authentication
	 * @return AuthType
	 * @see AuthType
	 */
	public AuthType getScanResultSecurity(String capabilities) {
	    Log.i(TAG, "* getScanResultSecurity");

	    if (capabilities.contains(AuthType.WEP.name())) {
	    	return AuthType.WEP;
	    }
	    else if (capabilities.contains("WPA")) {
	    	if (capabilities.contains("WPA2"))
		    	return AuthType.WPA2_AUTO;
	    	else
	    		return AuthType.WPA_AUTO;
	    }	       
		return AuthType.OPEN;

	}
	
	//================================================================
	/**
	 * @return the Wi-Fi AP that we're logged into
	 */
	public String getCurrentNetworkSSID(){
		
		String s = m_wifi.getConnectionInfo().getSSID();
		return s;
	}
	
	/**
	 * @return compare result of two SSID strings.
	 */
	public static boolean isSsidEquals(String ssid1, String ssid2)
	{
		if (ssid1 == null || ssid1.length() == 0 || ssid2 == null || ssid2.length() == 0)
			return false;
		if (ssid1.startsWith("\"")){
			ssid1 = ssid1.replace("\"", "");
		}
		if (ssid2.startsWith("\"")){
			ssid2 = ssid2.replace("\"", "");
		}
		return ssid1.equals(ssid2);
	}
	
	
	//================================================================
	/**
	 * Connect to an AJ Wi-Fi Access Point
	 * @param isPasswordASCII indicates whether the password is in ASCII format or HEX.
	 * @param networkName SSID of the network
	 * @param passkey Wi-Fi password
	 * @param authType AuthType 
	 */
	public boolean connectToAP(String name, String password, boolean isPasswordASCII, short authType) {

		Log.i(TAG, "* connectToAP");
	    Log.d(TAG, "# password " + password);	  
	    // try to connect to the WIFI AP if it's already in the ConfiguredNetworks
	    // if not found create a new one and connect to it.
	    WifiConfiguration wifiConfiguration =null;	
	    // debug info  
		final List<WifiConfiguration> wifiConfigs=m_wifi.getConfiguredNetworks();		
		StringBuffer buff=new StringBuffer();
		for (WifiConfiguration w : wifiConfigs){
			if (w.SSID != null ){
				if (w.SSID.startsWith("\"")){
					w.SSID = w.SSID.replace("\"", "");
				}
				if (w.SSID.length()>1){
					buff.append(w.SSID).append(",");
				}
			}
		}		
		Log.d(TAG, "ConfiguredNetworks "+buff.toString().substring(0,buff.length()-1));		
		int m_networkId = -1;
		for (WifiConfiguration w : wifiConfigs) {
			if (w.SSID != null &&  isSsidEquals(w.SSID,name)){				
				wifiConfiguration=w;
				m_networkId=wifiConfiguration.networkId;
				Log.d(TAG, "connectToSoftAP found "+name  + " in ConfiguredNetworks. networkId = " + m_networkId);
				break;
			}		
		}
		//SSID  already configured		
		if (wifiConfiguration!=null){					
			wifiConfiguration.status= WifiConfiguration.Status.CURRENT;			
			int t=m_wifi.updateNetwork(wifiConfiguration);
			Log.d(TAG, "connectToSoftAP updateNetwork id "+t);
			boolean res;
			res=m_wifi.enableNetwork(wifiConfiguration.networkId, false);
			Log.d(TAG, "connectToSoftAP enableNetwork [false] status="+res);
			res=m_wifi.disconnect();	
			Log.d(TAG, "connectToSoftAP disconnect  status="+res);
			res=m_wifi.enableNetwork(m_networkId, true);
			Log.d(TAG, "connectToSoftAP enableNetwork [true] status=" + res);		
			return res;
		}
		else{
			Log.d(TAG, "connectToSoftAP didn't find "+name  + " in ConfiguredNetworks");
			wifiConfiguration=new WifiConfiguration();
		}
					
		AuthType authenticationType = AuthType.getAuthTypeById(authType);

		switch (authenticationType) {
				
		case OPEN: {
			wifiConfiguration.SSID = "\"" + name + "\"";
			wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
			m_networkId = m_wifi.addNetwork(wifiConfiguration);
			Log.d(TAG, "addNetwork returned " + m_networkId);
			break;
		}

		case WEP: {
			
			wifiConfiguration.SSID = "\"" + name + "\"";
			if (isPasswordASCII){
				wifiConfiguration.wepKeys[0] = "\"" + password + "\"";
			}
			else{
				wifiConfiguration.wepKeys[0] = password ;
			}			
			wifiConfiguration.priority = 40;
			wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
			wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);
			wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.WPA);
			wifiConfiguration.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
			wifiConfiguration.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED);
			wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
			wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
			wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40);
			wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104);
			wifiConfiguration.wepTxKeyIndex = 0;
			m_networkId = m_wifi.addNetwork(wifiConfiguration);
			Log.d(TAG, "addNetwork returned " + m_networkId);
			break;
		}
		
		case WPA_AUTO:
		case WPA_TKIP:
		case WPA_CCMP:
		case WPA2_AUTO:
		case WPA2_TKIP:
		case WPA2_CCMP: {
			wifiConfiguration.SSID = "\"" + name + "\"";
			wifiConfiguration.preSharedKey = "\"" + password + "\"";
			wifiConfiguration.hiddenSSID = true;
			wifiConfiguration.status = WifiConfiguration.Status.ENABLED;
			wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
			wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);
			wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
			wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
			wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);
			wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);
			wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.WPA);

			m_networkId = m_wifi.addNetwork(wifiConfiguration);
			Log.d(TAG, "addNetwork returned " + m_networkId);
			break;
		}
		default:
			break;
		}

		boolean changeHappened = m_wifi.saveConfiguration();

		if (m_networkId != -1 && changeHappened) {
			Log.d(TAG, "Successfully configured Wifi. Change happened");
		} else {
			Log.w(TAG, "WifiManager.saveConfiguration failed. Change did NOT happen");
		}

		// enable the network
		boolean networkEnabled = m_wifi.enableNetwork(m_networkId, true);
		if (!networkEnabled) {
			Log.w(TAG, "WifiManager.enableNetwork failed");
		}
		return networkEnabled;
	}
	//================================================================
}
